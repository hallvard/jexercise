JExercise - test-based Java exercise
====================================
JExercise implements support for test-based exercises, by integrating an exercise model with Eclipse's UI, the Eclipse JDT and JUnit. There is also a simplified standalone version which uses Java annotations and reflection.

Overview of plugins
-------------------
 * no.hal.jex: defines the JExercise EMF data model, consisting of 1) the structure of the solution in terms of Java classes and members and 2) the requirements in terms of elements of the solution and passed JUnit tests.
 * no.hal.jex.edit: generated from no.hal.jex by the EMF genmodel generator
 * no.hal.jex.jdt: implements support for using the JDT's Java model for validating requirements
 * no.hal.jex.java: implements support for using Java reflection for validating requirements
 * no.hal.jex.ui: provides integration with Eclipse JDT's Java model and JUnit launcher, and a UI with JExercise view and editor
 * no.hal.jex.standalone: provides a Java Swing UI for viewing exercises and running the JUnit tests, using Java annotations and reflection
 * no.hal.jex.feature: the JExercise feature, which combines the above into a unit that's easy to install
 * no.hal.jex.collection: a collection of JExercises, based on JUnit tests with annotations

no.hal.jex
----------
The JExercise data model consists of
1. the Java elements, i.e. classes and members, that will need to be implemented as part of the exercise, independent of when they should be implemented. Note that the test classes are also represented in this part of the model.
2. a breakdown of the exercise into parts, with a hierarchical structure of requirements, both for implemented Java elements and JUnit tests that must pass, and the requirement texts and points received if they pass
The first part essentially represents what JExercise will be comparing with the student's code, while the second determines the order the code must be written and tests must pass. It is part 2. that is visualized in the JExercise view.

There are two ways of creating a model:
1. manually, by creating and linking EMF objects (there is support in the editor for generating it from the solution)
2. automatically, from annotations in the JUnit test classes

Although variant 2 is less powerful and flexible, we nevertheless recommend it, since the JUnit test classes must be written anyway and it's a lot easier to add the annotations than authoring a JExercise model (jex file) by hand.

no.hal.jex.ui
-------------
This plugin contains an editor for authoring exercises, based on the one generated by the EMF generator, and the JExercise view used by the student while working on the exercise. The general operation of the JExercise view is as follows:
 * A dropdown is automatically populated with exercises, based on the jex files and the annotated JUnit test classes found in your exercise project. Selecting an element populates the main tree view of the exercise.
 * The tree view shows the exercise structure and uses icons to indicate which of the requirements are met or not
 * Whenever code is edited (and saved), the JexManager is notified, upon which it revalidates all the requirements related to Java elements
 * The user may double-click requirements for passing tests, and hence launch the corresponding JUnit tests (using the Eclipse's JUnit plugin)
 * The JUnit plugin notifies the JexManager of any results, upon which it revalidates corresponding requirements. Note that this also happens if the student runs the tests directly from the JUnit view.
 * Whenever requirements are revalidated, the tree (icons) updates and the points are recalculated
