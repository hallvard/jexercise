<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:exercise="platform:/plugin/no.hal.learning.exercise.model/model/exercise.ecore" xmlns:jdt="platform:/plugin/no.hal.learning.exercise.jdt/model/jdt-exercise.ecore" xmlns:junit="platform:/plugin/no.hal.learning.exercise.junit/model/junit-exercise.ecore" xmlns:workbench="platform:/plugin/no.hal.learning.exercise.workbench/model/workbench-exercise.ecore">
  <exercise:Exercise>
    <parts xsi:type="exercise:ExercisePart" title="BinaryComputingIterator">
      <tasks xsi:type="exercise:Task">
        <q xsi:type="exercise:StringQuestion" question="Write source code for the BinaryComputingIterator class."/>
        <a xsi:type="jdt:JdtSourceEditAnswer" className="interfaces.BinaryComputingIterator"/>
      </tasks>
      <tasks xsi:type="exercise:Task">
        <q xsi:type="exercise:StringQuestion" question="Run the BinaryComputingIteratorTest JUnit test."/>
        <a xsi:type="junit:JunitTestAnswer" testRunName="interfaces.BinaryComputingIteratorTest"/>
      </tasks>
    </parts>
    <parts xsi:type="exercise:ExercisePart" title="Tool usage">
      <tasks xsi:type="exercise:Task">
        <q xsi:type="exercise:StringQuestion" question="Use breakpoints to debug code."/>
        <a xsi:type="workbench:DebugEventAnswer" action="suspend.breakpoint"/>
      </tasks>
      <tasks xsi:type="exercise:Task">
        <q xsi:type="exercise:StringQuestion" question="Use the debug command Step Over"/>
        <a xsi:type="workbench:CommandExecutionAnswer" elementId="org.eclipse.debug.ui.commands.StepOver" action="executeSuccess"/>
      </tasks>
      <tasks xsi:type="exercise:Task">
        <q xsi:type="exercise:StringQuestion" question="Use the debug command Step Into"/>
        <a xsi:type="workbench:CommandExecutionAnswer" elementId="org.eclipse.debug.ui.commands.StepInto" action="executeSuccess"/>
      </tasks>
      <tasks xsi:type="exercise:Task">
        <q xsi:type="exercise:StringQuestion" question="Use the Variables view"/>
        <a xsi:type="workbench:PartTaskAnswer" elementId="org.eclipse.debug.ui.VariableView" action="activated"/>
      </tasks>
    </parts>
  </exercise:Exercise>
  <exercise:ExerciseProposals exercise="/0">
    <proposals exercisePart="/0/@parts.0">
      <proposals xsi:type="jdt:JdtSourceEditProposal" question="/0/@parts.0/@tasks.0/@q" answer="/0/@parts.0/@tasks.0/@a">
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457350509264" sizeMeasure="5">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;public class BinaryComputingIterator {&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457350535514" sizeMeasure="19">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return false;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457350647362" sizeMeasure="26">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return false;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double arg0, Double arg1) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457350693187" sizeMeasure="26">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return false;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457350801767" sizeMeasure="29" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1 = 0.0;&#xA;&#x9;private double default2 = 0.0;&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return false;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457350889251" sizeMeasure="37" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1 = 0.0;&#xA;&#x9;private double default2 = 0.0;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> iterator2) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return false;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457350918064" sizeMeasure="37" errorCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1 = 0.0;&#xA;&#x9;private double default2 = 0.0;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> iterator2 BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return false;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457350922806" sizeMeasure="37" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1 = 0.0;&#xA;&#x9;private double default2 = 0.0;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return false;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351003742" sizeMeasure="41" errorCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2,)&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return false;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351030719" sizeMeasure="41" errorCount="10">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double defailt1, Double default2, BinaryOperator&lt;Double operator>)&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return false;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351038538" sizeMeasure="41" errorCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double defailt1, Double default2, BinaryOperator&lt;Double> operator)&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return false;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351066168" sizeMeasure="44" errorCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2,&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return false;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351067467" sizeMeasure="44" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return false;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351248273" sizeMeasure="45" errorCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if &#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351274598" sizeMeasure="48" errorCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if &#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351305751" sizeMeasure="50" errorCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!(this.iterator1.hasNext() || this.iterator2.hasNext())){&#xA;&#x9;&#x9;&#x9;return&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351314469" sizeMeasure="51" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!(this.iterator1.hasNext() || this.iterator2.hasNext())){&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return true;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351361545" sizeMeasure="50" errorCount="1" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!(this.iterator1.hasNext() || this.iterator2.hasNext())){&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return true;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351392555" sizeMeasure="47" errorCount="1" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351447797" sizeMeasure="49" errorCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if ()!(hasNext())) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351451110" sizeMeasure="49" errorCount="1" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (!(hasNext())) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351457837" sizeMeasure="50" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (!(hasNext())) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351505138" sizeMeasure="50" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351696041" sizeMeasure="51" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351785801" sizeMeasure="45" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351802246" sizeMeasure="46" errorCount="1" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = oerator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351803964" sizeMeasure="46" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457351811350" sizeMeasure="47" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457352189905" sizeMeasure="47" errorCount="1" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457352195478" sizeMeasure="53" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457352234334" sizeMeasure="52" errorCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;return (t operator u);&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457352239084" sizeMeasure="52" errorCount="4">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;return (t this.operator u);&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457352360687" sizeMeasure="47" errorCount="1" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457352386650" sizeMeasure="47" errorCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;return &#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457352489346" sizeMeasure="47" errorCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;return apply()&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457352517177" sizeMeasure="47" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457352550487" sizeMeasure="49" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;System.out.println(operator);&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;System.out.println(operator);&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457352568051" sizeMeasure="47" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457352654388" sizeMeasure="47" errorCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;()&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457352684940" sizeMeasure="46" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457352805460" sizeMeasure="47" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457352896853" sizeMeasure="47" errorCount="1" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457352903151" sizeMeasure="53" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353401608" sizeMeasure="55" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353438296" sizeMeasure="59" warningCount="4">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;//apply()&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353470821" sizeMeasure="62" errorCount="4">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply()&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply()&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;counter++;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353497867" sizeMeasure="63" errorCount="6">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply()&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply()&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply()&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;counter++;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353524609" sizeMeasure="63" errorCount="5">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply()&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply()&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next())&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;counter++;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353525746" sizeMeasure="63" errorCount="4">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply()&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply()&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;counter++;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353547610" sizeMeasure="63" errorCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply()&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;counter++;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353569388" sizeMeasure="63" errorCount="1" warningCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;counter++;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353579272" sizeMeasure="65" errorCount="1" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353594512" sizeMeasure="65" errorCount="1" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException();&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353613243" sizeMeasure="65" errorCount="1" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353641789" sizeMeasure="65" errorCount="1" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return 0;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353645423" sizeMeasure="65" errorCount="1" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353651379" sizeMeasure="65" errorCount="1" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353708854" sizeMeasure="63" errorCount="2" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(); &#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353777248" sizeMeasure="65" errorCount="3" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.sql.Array;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator1, operator); &#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353786829" sizeMeasure="66" errorCount="2" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.sql.Array;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator1, operator); &#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353803900" sizeMeasure="67" errorCount="2" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.sql.Array;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator1, operator); &#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353824721" sizeMeasure="67" errorCount="1" warningCount="5">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.sql.Array;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator1, (x, y) -> x+y); &#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353842735" sizeMeasure="69" errorCount="2" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.sql.Array;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator1, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;binaryIterator.next();&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353855738" sizeMeasure="69" errorCount="1" warningCount="4">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.sql.Array;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator1, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;calc.next();&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353878068" sizeMeasure="68" warningCount="4">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.sql.Array;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator1, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;calc.next();&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353900814" sizeMeasure="68" warningCount="4">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.sql.Array;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;private int counter;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator1, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353917982" sizeMeasure="67" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.sql.Array;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator1, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353923132" sizeMeasure="66" warningCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.sql.Array;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator1, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457353934389" sizeMeasure="66" warningCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.sql.Array;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator2, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354026014" sizeMeasure="65" warningCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>, BinaryOperator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;// TODO Auto-generated method stub&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator2, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354119085" sizeMeasure="64" errorCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double apply(Double t, Double u) {&#xA;&#x9;&#x9;return &#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator2, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354126255" sizeMeasure="59" errorCount="3" warningCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator2, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354242164" sizeMeasure="59" errorCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;operatir.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator2, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354261607" sizeMeasure="59">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return 0.0;&#x9;//?&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator2, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354302605" sizeMeasure="58" errorCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator2, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354308949" sizeMeasure="58" errorCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator2, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354318576" sizeMeasure="58" errorCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator2, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354356786" sizeMeasure="61">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return -1.0;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator2, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354428657" sizeMeasure="61" errorCount="3">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;trow new IllegalStateException(&quot;None of the iterators has next&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator2, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354436093" sizeMeasure="61">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;None of the iterators has next&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator2, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354733955" sizeMeasure="62">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;None of the iterators has next&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator2, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354762426" sizeMeasure="64">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;None of the iterators has next&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator2, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354961824" sizeMeasure="64">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;None of the iterators has next&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354968234" sizeMeasure="65">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;None of the iterators has next&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354998040" sizeMeasure="65" errorCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;None of the iterators has next&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, 0, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457354999550" sizeMeasure="65">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;None of the iterators has next&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, 0.0, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457355009607" sizeMeasure="65">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;None of the iterators has next&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457355048023" sizeMeasure="70">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;if (default1 == null) {&#xA;&#x9;&#x9;&#x9;this.default1 = 0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;None of the iterators has next&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457355074842" sizeMeasure="75">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;if (default1 == null) {&#xA;&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (default2 == null) {&#xA;&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;None of the iterators has next&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457355313445" sizeMeasure="75">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;if (default1 == null) {&#xA;&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (default2 == null) {&#xA;&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457355315477" sizeMeasure="75">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;if (default1 == null) {&#xA;&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (default2 == null) {&#xA;&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457355521505" sizeMeasure="77">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457355531331" sizeMeasure="77">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, 0.0, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457355607603" sizeMeasure="77">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, 0.0, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457355904909" sizeMeasure="77" errorCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (this.iterator1.hasNext() &amp;&amp; this.iterator2.hasNext()){&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, 0.0, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457355950481" sizeMeasure="77" errorCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (this.iterator1.hasNext() &amp;&amp; this.iterator2.hasNext()){&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, 0.0, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457355976163" sizeMeasure="77">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, 0.0, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457356027182" sizeMeasure="79">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),this.default2));&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, 0.0, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457356047304" sizeMeasure="80">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(this.default1, iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),this.default2));&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, 0.0, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457356112581" sizeMeasure="78">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;if (default1 == null) {&#xA;&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (default2 == null) {&#xA;&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(this.default1, iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),this.default2));&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, 0.0, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457356145032" sizeMeasure="80">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(this.default1, iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),this.default2));&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, 0.0, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457356329583" sizeMeasure="80">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(this.default1, iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),this.default2));&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, 0.0, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457356356254" sizeMeasure="80">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(this.default1, iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),this.default2));&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457356385441" sizeMeasure="80">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;if (default1 == null) {&#xA;&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (default2 == null) {&#xA;&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;//&#x9;&#x9;this.default1 = default1;&#xA;//&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(this.default1, iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),this.default2));&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457356583397" sizeMeasure="80">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;if (default1 == null) {&#xA;&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (default2 == null) {&#xA;&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;//&#x9;&#x9;this.default1 = default1;&#xA;//&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(this.default1, iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),this.default2));&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457356591783" sizeMeasure="80">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;this.default1 = default1;&#xA;//&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(this.default1, iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),this.default2));&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457356596596" sizeMeasure="80">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;if (default1 == null) {&#xA;&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (default2 == null) {&#xA;&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;//&#x9;&#x9;this.default1 = default1;&#xA;//&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(this.default1, iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),this.default2));&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;System.out.println(this.operator.apply(iterator1.next(),iterator2.next()));&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457356667037" sizeMeasure="77">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;if (default1 == null) {&#xA;&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (default2 == null) {&#xA;&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;//&#x9;&#x9;this.default1 = default1;&#xA;//&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457356678768" sizeMeasure="77">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457356705250" sizeMeasure="77">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;if (default1 == null) {&#xA;&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (default2 == null) {&#xA;&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;//&#x9;&#x9;this.default1 = default1;&#xA;//&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457358432304" sizeMeasure="77">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;return this.iterator1.hasNext() || this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457358522857" sizeMeasure="86" errorCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; this.default2 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;//|| this.iterator2.hasNext();&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457358528464" sizeMeasure="85" errorCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; this.default2 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457358569522" sizeMeasure="85" errorCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; this.default2 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457358641887" sizeMeasure="85" errorCount="2">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private double default1;&#xA;&#x9;private double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; !(this.default2 != null)) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457358654512" sizeMeasure="85">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private Double default1;&#xA;&#x9;private Double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; !(this.default2 != null)) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457358663137" sizeMeasure="85" errorCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private Double default1;&#xA;&#x9;private Double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; this.default2 == null)) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457358671599" sizeMeasure="85">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private Double default1;&#xA;&#x9;private Double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;//&#x9;&#x9;if (default1 == null) {&#xA;//&#x9;&#x9;&#x9;this.default1 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default1 = default1;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;if (default2 == null) {&#xA;//&#x9;&#x9;&#x9;this.default2 = 0.0;&#xA;//&#x9;&#x9;}&#xA;//&#x9;&#x9;else {&#xA;//&#x9;&#x9;&#x9;this.default2 = default2;&#x9;&#x9;&#x9;&#xA;//&#x9;&#x9;}&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; this.default2 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457358680701" sizeMeasure="73">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private Double default1;&#xA;&#x9;private Double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; this.default2 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457358796775" sizeMeasure="73">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private Double default1;&#xA;&#x9;private Double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; this.default2 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457358848330" sizeMeasure="76" errorCount="1">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private Double default1;&#xA;&#x9;private Double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if !(this.iterator1.hasNext() || this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; this.default2 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457358867531" sizeMeasure="76">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private Double default1;&#xA;&#x9;private Double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; !this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; this.default2 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457359062058" sizeMeasure="76">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private Double default1;&#xA;&#x9;private Double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; !this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; this.default2 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457362102216" sizeMeasure="78">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private Double default1;&#xA;&#x9;private Double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;//Setter klassens egne felter lik argumentene i konstruktren&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;//Setter klassens egne felter lik argumentene i konstruktren&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; !this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; this.default2 == null) {&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457362168995" sizeMeasure="82">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private Double default1;&#xA;&#x9;private Double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;//Setter klassens egne felter lik argumentene i konstruktren&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;//Setter klassens egne felter lik argumentene i konstruktren&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; !this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;//Hvis bde iterator1 (i1) og iterator2 (i2) er tomme&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;//Hvis i1 er tom og ikke har default&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; this.default2 == null) {&#xA;&#x9;&#x9;&#x9;//Hvis i2 er tom og ikke har default&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;//Hvis ingen av de nevnt over: returner true&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457362175122" sizeMeasure="82">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private Double default1;&#xA;&#x9;private Double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;//Setter klassens egne felter lik argumentene i konstruktren&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;//Setter klassens egne felter lik argumentene i konstruktren&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; !this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;//Hvis bde iterator1 (i1) og iterator2 (i2) er tomme&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;//Hvis i1 er tom og ikke har default&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; this.default2 == null) {&#xA;&#x9;&#x9;&#x9;//Hvis i2 er tom og ikke har default&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;//Hvis ingen av if-ene nevnt over: returner true&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457362248537" sizeMeasure="87">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private Double default1;&#xA;&#x9;private Double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;//Setter klassens egne felter lik argumentene i konstruktren&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;//Setter klassens egne felter lik argumentene i konstruktren&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; !this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;//Hvis bde iterator1 (i1) og iterator2 (i2) er tomme&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;//Hvis i1 er tom og ikke har default&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; this.default2 == null) {&#xA;&#x9;&#x9;&#x9;//Hvis i2 er tom og ikke har default&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;//Hvis ingen av if-ene nevnt over: returner true&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;//Hvis i1 er tom, bruk default&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;//Hvis i2 er tom, bruk default&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;//Hvis hverken i1 eller i2 er tom, bruk begge&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;//Hvis next() blir kalt nr begge iteratorene er tomme&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;//For testing&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
        <attempts xsi:type="jdt:JdtSourceEditEvent" timestamp="1457362270463" sizeMeasure="87">
          <edit xsi:type="exercise:StringEdit" storedString="package interfaces;&#xA;&#xA;import java.util.Arrays;&#xA;import java.util.Iterator;&#xA;import java.util.function.BinaryOperator;&#xA;&#xA;public class BinaryComputingIterator implements Iterator&lt;Double>{&#xA;&#xA;&#x9;private Double default1;&#xA;&#x9;private Double default2;&#xA;&#x9;private Iterator&lt;Double> iterator1;&#xA;&#x9;private Iterator&lt;Double> iterator2;&#xA;&#x9;private BinaryOperator&lt;Double> operator;&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;//Setter klassens egne felter lik argumentene i konstruktren&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;BinaryComputingIterator(Iterator&lt;Double> iterator1, Iterator&lt;Double> &#xA;&#x9;iterator2, Double default1, Double default2, BinaryOperator&lt;Double> operator) {&#xA;&#x9;&#x9;//Setter klassens egne felter lik argumentene i konstruktren&#xA;&#x9;&#x9;this.iterator1 = iterator1;&#xA;&#x9;&#x9;this.iterator2 = iterator2;&#xA;&#x9;&#x9;this.default1 = default1;&#xA;&#x9;&#x9;this.default2 = default2;&#xA;&#x9;&#x9;this.operator = operator;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@Override&#xA;&#x9;public boolean hasNext() {&#xA;&#x9;&#x9;if (!this.iterator1.hasNext() &amp;&amp; !this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;//Hvis bde iterator1 (i1) og iterator2 (i2) er tomme&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator1.hasNext() &amp;&amp; this.default1 == null) {&#xA;&#x9;&#x9;&#x9;//Hvis i1 er tom og ikke har default&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (!this.iterator2.hasNext() &amp;&amp; this.default2 == null) {&#xA;&#x9;&#x9;&#x9;//Hvis i2 er tom og ikke har default&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;//Hvis ingen av if-ene nevnt over: returner true&#xA;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;@Override&#xA;&#x9;public Double next() {&#xA;&#x9;&#x9;if (hasNext()) {&#xA;&#x9;&#x9;&#x9;if (!this.iterator1.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;//Hvis i1 er tom, bruk default&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(this.default1, iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (!this.iterator2.hasNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;//Hvis i2 er tom, bruk default&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),this.default2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;//Hvis hverken i1 eller i2 er tom, bruk begge&#xA;&#x9;&#x9;&#x9;&#x9;return (Double)this.operator.apply(iterator1.next(),iterator2.next());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;//Hvis next() blir kalt nr begge iteratorene er tomme&#xA;&#x9;&#x9;&#x9;throw new IllegalStateException(&quot;Both iterators are out of objects.&quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;public static void main(String[] args) {&#xA;&#x9;&#x9;//For testing&#xA;&#x9;&#x9;Iterator&lt;Double> iterator1 = Arrays.asList(2.0, 3.0).iterator();&#xA;&#x9;&#x9;Iterator&lt;Double> iterator2 = Arrays.asList(5.0).iterator();&#xA;&#x9;&#x9;BinaryComputingIterator calc = new BinaryComputingIterator(iterator1, &#xA;&#x9;&#x9;&#x9;&#x9;iterator2, null, 10.0, (x, y) -> x+y);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;&#x9;System.out.println(calc.next());&#xA;&#x9;&#x9;System.out.println(calc.hasNext());&#xA;&#x9;}&#xA;}&#xA;"/>
        </attempts>
      </proposals>
      <proposals xsi:type="junit:JunitTestProposal" question="/0/@parts.0/@tasks.1/@q" answer="/0/@parts.0/@tasks.1/@a" completion="0.47126436781609193">
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457352519707" completion="1.0" successCount="1"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457352522160" completion="1.0" successCount="2"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457352526480" completion="0.6666666666666666" successCount="2" errorCount="1"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457352527634" completion="0.5" successCount="2" errorCount="2"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457352528630" completion="0.4" successCount="2" errorCount="3"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457352531111" completion="0.3333333333333333" successCount="2" errorCount="4"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457352553702" completion="0.42857142857142855" successCount="3" errorCount="4"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457352559987" completion="0.5" successCount="4" errorCount="4"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457354806539" completion="0.5555555555555556" successCount="5" errorCount="4"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457354807398" completion="0.6" successCount="6" errorCount="4"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457354808337" completion="0.5454545454545454" successCount="6" errorCount="5"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457354811394" completion="0.5" successCount="6" failureCount="1" errorCount="5"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457354812381" completion="0.5384615384615384" successCount="7" failureCount="1" errorCount="5"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457354813346" completion="0.5714285714285714" successCount="8" failureCount="1" errorCount="5"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457354818109" completion="0.5333333333333333" successCount="8" failureCount="2" errorCount="5"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355083505" completion="0.5625" successCount="9" failureCount="2" errorCount="5"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355084450" completion="0.5294117647058824" successCount="9" failureCount="3" errorCount="5"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355086562" completion="0.5" successCount="9" failureCount="4" errorCount="5"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355325077" completion="0.47368421052631576" successCount="9" failureCount="5" errorCount="5"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355538906" completion="0.5" successCount="10" failureCount="5" errorCount="5"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355539800" completion="0.5238095238095238" successCount="11" failureCount="5" errorCount="5"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355540693" completion="0.5" successCount="11" failureCount="6" errorCount="5"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355542039" completion="0.4782608695652174" successCount="11" failureCount="7" errorCount="5"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355544270" completion="0.4583333333333333" successCount="11" failureCount="7" errorCount="6"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355545672" completion="0.48" successCount="12" failureCount="7" errorCount="6"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355548258" completion="0.5" successCount="13" failureCount="7" errorCount="6"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355565565" completion="0.48148148148148145" successCount="13" failureCount="7" errorCount="7"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355611506" completion="0.4642857142857143" successCount="13" failureCount="7" errorCount="8"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355612448" completion="0.4482758620689655" successCount="13" failureCount="8" errorCount="8"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355640966" completion="0.43333333333333335" successCount="13" failureCount="9" errorCount="8"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355641995" completion="0.41935483870967744" successCount="13" failureCount="9" errorCount="9"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355945203" completion="0.40625" successCount="13" failureCount="9" errorCount="10"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355945218" completion="0.3939393939393939" successCount="13" failureCount="9" errorCount="11"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355960996" completion="0.38235294117647056" successCount="13" failureCount="9" errorCount="12"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355961837" completion="0.37142857142857144" successCount="13" failureCount="9" errorCount="13"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457355962954" completion="0.3888888888888889" successCount="14" failureCount="9" errorCount="13"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457356051440" completion="0.3783783783783784" successCount="14" failureCount="9" errorCount="14"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457356063517" completion="0.3684210526315789" successCount="14" failureCount="9" errorCount="15"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457356077390" completion="0.358974358974359" successCount="14" failureCount="9" errorCount="16"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457356114292" completion="0.35" successCount="14" failureCount="9" errorCount="17"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457356117850" completion="0.34146341463414637" successCount="14" failureCount="9" errorCount="18"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457356126462" completion="0.3333333333333333" successCount="14" failureCount="9" errorCount="19"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457356147248" completion="0.32558139534883723" successCount="14" failureCount="9" errorCount="20"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457356313615" completion="0.3181818181818182" successCount="14" failureCount="9" errorCount="21"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457356332061" completion="0.3111111111111111" successCount="14" failureCount="9" errorCount="22"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457356333387" completion="0.30434782608695654" successCount="14" failureCount="9" errorCount="23"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457356361368" completion="0.2978723404255319" successCount="14" failureCount="9" errorCount="24"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457356364638" completion="0.2916666666666667" successCount="14" failureCount="9" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457356713203" completion="0.30612244897959184" successCount="15" failureCount="9" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457356714977" completion="0.3" successCount="15" failureCount="10" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457356970696" completion="0.29411764705882354" successCount="15" failureCount="11" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457357559668" completion="0.28846153846153844" successCount="15" failureCount="12" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457357714187" completion="0.2830188679245283" successCount="15" failureCount="13" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457357943280" completion="0.2777777777777778" successCount="15" failureCount="14" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457357977808" completion="0.2909090909090909" successCount="16" failureCount="14" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358020316" completion="0.2857142857142857" successCount="16" failureCount="15" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358687447" completion="0.2982456140350877" successCount="17" failureCount="15" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358693835" completion="0.3103448275862069" successCount="18" failureCount="15" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358694650" completion="0.3220338983050847" successCount="19" failureCount="15" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358695432" completion="0.3333333333333333" successCount="20" failureCount="15" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358696336" completion="0.3442622950819672" successCount="21" failureCount="15" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358698266" completion="0.3548387096774194" successCount="22" failureCount="15" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358698968" completion="0.3492063492063492" successCount="22" failureCount="16" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358724895" completion="0.34375" successCount="22" failureCount="17" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358747464" completion="0.3384615384615385" successCount="22" failureCount="18" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358758281" completion="0.3333333333333333" successCount="22" failureCount="19" errorCount="25"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358850332" completion="0.3283582089552239" successCount="22" failureCount="19" errorCount="26"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358851489" completion="0.3235294117647059" successCount="22" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358874488" completion="0.3333333333333333" successCount="23" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358877053" completion="0.34285714285714286" successCount="24" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358877829" completion="0.352112676056338" successCount="25" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358878686" completion="0.3611111111111111" successCount="26" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358881523" completion="0.3698630136986301" successCount="27" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358882188" completion="0.3783783783783784" successCount="28" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457358883143" completion="0.38666666666666666" successCount="29" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457359071881" completion="0.39473684210526316" successCount="30" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457359072592" completion="0.4025974025974026" successCount="31" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457359073334" completion="0.41025641025641024" successCount="32" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457359074228" completion="0.4177215189873418" successCount="33" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457359075132" completion="0.425" successCount="34" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457359076092" completion="0.43209876543209874" successCount="35" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457360990440" completion="0.43902439024390244" successCount="36" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457360991001" completion="0.4457831325301205" successCount="37" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457360991906" completion="0.4523809523809524" successCount="38" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457360992705" completion="0.4588235294117647" successCount="39" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457360993481" completion="0.46511627906976744" successCount="40" failureCount="19" errorCount="27"/>
        <attempts xsi:type="junit:JunitTestEvent" timestamp="1457360994556" completion="0.47126436781609193" successCount="41" failureCount="19" errorCount="27"/>
      </proposals>
    </proposals>
    <proposals exercisePart="/0/@parts.1">
      <proposals xsi:type="workbench:DebugEventProposal" question="/0/@parts.1/@tasks.0/@q" answer="/0/@parts.1/@tasks.0/@a" completion="0.0" performedCount="4">
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
      </proposals>
      <proposals xsi:type="workbench:CommandExecutionProposal" question="/0/@parts.1/@tasks.1/@q" answer="/0/@parts.1/@tasks.1/@a"/>
      <proposals xsi:type="workbench:CommandExecutionProposal" question="/0/@parts.1/@tasks.2/@q" answer="/0/@parts.1/@tasks.2/@a" completion="0.0" performedCount="41">
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
      </proposals>
      <proposals xsi:type="workbench:PartTaskProposal" question="/0/@parts.1/@tasks.3/@q" answer="/0/@parts.1/@tasks.3/@a" completion="0.0" performedCount="4">
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
        <attempts timestamp="-1" completion="0.0"/>
      </proposals>
    </proposals>
  </exercise:ExerciseProposals>
</xmi:XMI>
