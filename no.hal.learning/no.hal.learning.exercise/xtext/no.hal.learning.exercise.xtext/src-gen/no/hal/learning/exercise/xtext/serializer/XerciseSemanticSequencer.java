/*
 * generated by Xtext 2.9.1
 */
package no.hal.learning.exercise.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import no.hal.learning.exercise.BooleanAnswer;
import no.hal.learning.exercise.Exercise;
import no.hal.learning.exercise.ExercisePackage;
import no.hal.learning.exercise.ExercisePart;
import no.hal.learning.exercise.ExercisePartRef;
import no.hal.learning.exercise.ManyOptionsAnswer;
import no.hal.learning.exercise.NumberAnswer;
import no.hal.learning.exercise.Option;
import no.hal.learning.exercise.SingleOptionsAnswer;
import no.hal.learning.exercise.StringAnswer;
import no.hal.learning.exercise.StringQuestion;
import no.hal.learning.exercise.Task;
import no.hal.learning.exercise.TaskRef;
import no.hal.learning.exercise.jdt.JdtLaunchAnswer;
import no.hal.learning.exercise.jdt.JdtPackage;
import no.hal.learning.exercise.jdt.JdtSourceEditAnswer;
import no.hal.learning.exercise.junit.JunitPackage;
import no.hal.learning.exercise.junit.JunitTestAnswer;
import no.hal.learning.exercise.workbench.CommandExecutionAnswer;
import no.hal.learning.exercise.workbench.DebugEventAnswer;
import no.hal.learning.exercise.workbench.PartTaskAnswer;
import no.hal.learning.exercise.workbench.PerspectiveTaskAnswer;
import no.hal.learning.exercise.workbench.WorkbenchPackage;
import no.hal.learning.exercise.xtext.services.XerciseGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class XerciseSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private XerciseGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ExercisePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExercisePackage.BOOLEAN_ANSWER:
				sequence_BooleanAnswer(context, (BooleanAnswer) semanticObject); 
				return; 
			case ExercisePackage.EXERCISE:
				sequence_Exercise(context, (Exercise) semanticObject); 
				return; 
			case ExercisePackage.EXERCISE_PART:
				if (rule == grammarAccess.getAnonymousExercisePartRule()) {
					sequence_AnonymousExercisePart(context, (ExercisePart) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAbstractExercisePartRule()
						|| rule == grammarAccess.getExercisePartRule()) {
					sequence_ExercisePart(context, (ExercisePart) semanticObject); 
					return; 
				}
				else break;
			case ExercisePackage.EXERCISE_PART_REF:
				sequence_ExercisePartRef(context, (ExercisePartRef) semanticObject); 
				return; 
			case ExercisePackage.MANY_OPTIONS_ANSWER:
				sequence_ManyOptionsAnswer(context, (ManyOptionsAnswer) semanticObject); 
				return; 
			case ExercisePackage.NUMBER_ANSWER:
				sequence_NumberAnswer(context, (NumberAnswer) semanticObject); 
				return; 
			case ExercisePackage.OPTION:
				if (rule == grammarAccess.getManyOptionRule()) {
					sequence_ManyOption(context, (Option) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSingleBoxOptionRule()) {
					sequence_SingleBoxOption(context, (Option) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSingleListOptionRule()) {
					sequence_SingleListOption(context, (Option) semanticObject); 
					return; 
				}
				else break;
			case ExercisePackage.SINGLE_OPTIONS_ANSWER:
				if (rule == grammarAccess.getAnswerRule()
						|| rule == grammarAccess.getOptionsAnswerRule()
						|| rule == grammarAccess.getSingleOptionsAnswerRule()) {
					sequence_SingleBoxOptionsAnswer_SingleListOptionsAnswer(context, (SingleOptionsAnswer) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSingleBoxOptionsAnswerRule()) {
					sequence_SingleBoxOptionsAnswer(context, (SingleOptionsAnswer) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSingleListOptionsAnswerRule()) {
					sequence_SingleListOptionsAnswer(context, (SingleOptionsAnswer) semanticObject); 
					return; 
				}
				else break;
			case ExercisePackage.STRING_ANSWER:
				if (rule == grammarAccess.getRegexAnswerRule()) {
					sequence_RegexAnswer(context, (StringAnswer) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAnswerRule()
						|| rule == grammarAccess.getOptionAnswerRule()
						|| rule == grammarAccess.getSimpleAnswerRule()) {
					sequence_RegexAnswer_StringAnswer(context, (StringAnswer) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStringAnswerRule()) {
					sequence_StringAnswer(context, (StringAnswer) semanticObject); 
					return; 
				}
				else break;
			case ExercisePackage.STRING_QUESTION:
				sequence_StringQuestion(context, (StringQuestion) semanticObject); 
				return; 
			case ExercisePackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			case ExercisePackage.TASK_REF:
				sequence_TaskRef(context, (TaskRef) semanticObject); 
				return; 
			}
		else if (epackage == JdtPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case JdtPackage.JDT_LAUNCH_ANSWER:
				sequence_JdtLaunchAnswer(context, (JdtLaunchAnswer) semanticObject); 
				return; 
			case JdtPackage.JDT_SOURCE_EDIT_ANSWER:
				sequence_JdtSourceEditAnswer(context, (JdtSourceEditAnswer) semanticObject); 
				return; 
			}
		else if (epackage == JunitPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case JunitPackage.JUNIT_TEST_ANSWER:
				sequence_JunitTestAnswer(context, (JunitTestAnswer) semanticObject); 
				return; 
			}
		else if (epackage == WorkbenchPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case WorkbenchPackage.COMMAND_EXECUTION_ANSWER:
				sequence_CommandExecutionAnswer(context, (CommandExecutionAnswer) semanticObject); 
				return; 
			case WorkbenchPackage.DEBUG_EVENT_ANSWER:
				sequence_DebugEventAnswer(context, (DebugEventAnswer) semanticObject); 
				return; 
			case WorkbenchPackage.PART_TASK_ANSWER:
				sequence_PartTaskAnswer(context, (PartTaskAnswer) semanticObject); 
				return; 
			case WorkbenchPackage.PERSPECTIVE_TASK_ANSWER:
				sequence_PerspectiveTaskAnswer(context, (PerspectiveTaskAnswer) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AnonymousExercisePart returns ExercisePart
	 *
	 * Constraint:
	 *     tasks+=AbstractTask*
	 */
	protected void sequence_AnonymousExercisePart(ISerializationContext context, ExercisePart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Answer returns BooleanAnswer
	 *     OptionAnswer returns BooleanAnswer
	 *     SimpleAnswer returns BooleanAnswer
	 *     BooleanAnswer returns BooleanAnswer
	 *
	 * Constraint:
	 *     (value?='yes' | value?='true')?
	 */
	protected void sequence_BooleanAnswer(ISerializationContext context, BooleanAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Answer returns CommandExecutionAnswer
	 *     TaskAnswer returns CommandExecutionAnswer
	 *     CommandExecutionAnswer returns CommandExecutionAnswer
	 *
	 * Constraint:
	 *     (elementId=QName (action='executeSuccess' | action='executeFailure')?)
	 */
	protected void sequence_CommandExecutionAnswer(ISerializationContext context, CommandExecutionAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Answer returns DebugEventAnswer
	 *     TaskAnswer returns DebugEventAnswer
	 *     DebugEventAnswer returns DebugEventAnswer
	 *
	 * Constraint:
	 *     (
	 *         elementId=QName 
	 *         (
	 *             action='create' | 
	 *             action='terminate' | 
	 *             action='resume' | 
	 *             action='suspend' | 
	 *             action='stepInto' | 
	 *             action='stepOver' | 
	 *             action='stepReturn' | 
	 *             action='stepEnd' | 
	 *             action='breakpoint' | 
	 *             action='evaluation'
	 *         )?
	 *     )
	 */
	protected void sequence_DebugEventAnswer(ISerializationContext context, DebugEventAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractExercisePart returns ExercisePartRef
	 *     ExercisePartRef returns ExercisePartRef
	 *
	 * Constraint:
	 *     partRef=[ExercisePart|QName]
	 */
	protected void sequence_ExercisePartRef(ISerializationContext context, ExercisePartRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExercisePackage.Literals.EXERCISE_PART_REF__PART_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExercisePackage.Literals.EXERCISE_PART_REF__PART_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExercisePartRefAccess().getPartRefExercisePartQNameParserRuleCall_2_0_1(), semanticObject.getPartRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractExercisePart returns ExercisePart
	 *     ExercisePart returns ExercisePart
	 *
	 * Constraint:
	 *     (name=ID title=STRING tasks+=AbstractTask*)
	 */
	protected void sequence_ExercisePart(ISerializationContext context, ExercisePart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Exercise returns Exercise
	 *
	 * Constraint:
	 *     ((name=QName? title=STRING? parts+=AbstractExercisePart*) | parts+=AnonymousExercisePart)?
	 */
	protected void sequence_Exercise(ISerializationContext context, Exercise semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Answer returns JdtLaunchAnswer
	 *     JdtLaunchAnswer returns JdtLaunchAnswer
	 *     TaskAnswer returns JdtLaunchAnswer
	 *
	 * Constraint:
	 *     className=QName
	 */
	protected void sequence_JdtLaunchAnswer(ISerializationContext context, JdtLaunchAnswer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JdtPackage.Literals.JDT_LAUNCH_ANSWER__CLASS_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JdtPackage.Literals.JDT_LAUNCH_ANSWER__CLASS_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJdtLaunchAnswerAccess().getClassNameQNameParserRuleCall_2_0(), semanticObject.getClassName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Answer returns JdtSourceEditAnswer
	 *     JdtSourceEditAnswer returns JdtSourceEditAnswer
	 *     TaskAnswer returns JdtSourceEditAnswer
	 *
	 * Constraint:
	 *     (className=QName (methodNames+=ID methodNames+=ID*)?)
	 */
	protected void sequence_JdtSourceEditAnswer(ISerializationContext context, JdtSourceEditAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Answer returns JunitTestAnswer
	 *     JunitTestAnswer returns JunitTestAnswer
	 *     TaskAnswer returns JunitTestAnswer
	 *
	 * Constraint:
	 *     (testRunName=QName (methodNames+=ID methodNames+=ID*)?)
	 */
	protected void sequence_JunitTestAnswer(ISerializationContext context, JunitTestAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ManyOption returns Option
	 *
	 * Constraint:
	 *     (correct?='x'? option=OptionAnswer)
	 */
	protected void sequence_ManyOption(ISerializationContext context, Option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Answer returns ManyOptionsAnswer
	 *     OptionsAnswer returns ManyOptionsAnswer
	 *     ManyOptionsAnswer returns ManyOptionsAnswer
	 *
	 * Constraint:
	 *     options+=ManyOption+
	 */
	protected void sequence_ManyOptionsAnswer(ISerializationContext context, ManyOptionsAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Answer returns NumberAnswer
	 *     OptionAnswer returns NumberAnswer
	 *     SimpleAnswer returns NumberAnswer
	 *     NumberAnswer returns NumberAnswer
	 *
	 * Constraint:
	 *     (value=EDoubleObject errorMargin=EDoubleObject?)
	 */
	protected void sequence_NumberAnswer(ISerializationContext context, NumberAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Answer returns PartTaskAnswer
	 *     TaskAnswer returns PartTaskAnswer
	 *     PartTaskAnswer returns PartTaskAnswer
	 *
	 * Constraint:
	 *     (elementId=QName (action='activated' | action='broughtToTop' | action='closed' | action='deactivated' | action='opened')?)
	 */
	protected void sequence_PartTaskAnswer(ISerializationContext context, PartTaskAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Answer returns PerspectiveTaskAnswer
	 *     TaskAnswer returns PerspectiveTaskAnswer
	 *     PerspectiveTaskAnswer returns PerspectiveTaskAnswer
	 *
	 * Constraint:
	 *     (elementId=QName (action='activated' | action='changed')?)
	 */
	protected void sequence_PerspectiveTaskAnswer(ISerializationContext context, PerspectiveTaskAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegexAnswer returns StringAnswer
	 *
	 * Constraint:
	 *     (regexp?='/' value=STRING ignoreCase?='~'?)
	 */
	protected void sequence_RegexAnswer(ISerializationContext context, StringAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Answer returns StringAnswer
	 *     OptionAnswer returns StringAnswer
	 *     SimpleAnswer returns StringAnswer
	 *
	 * Constraint:
	 *     ((value=STRING ignoreCase?='~'?) | (regexp?='/' value=STRING ignoreCase?='~'?))
	 */
	protected void sequence_RegexAnswer_StringAnswer(ISerializationContext context, StringAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleBoxOption returns Option
	 *
	 * Constraint:
	 *     (correct?='x'? option=OptionAnswer)
	 */
	protected void sequence_SingleBoxOption(ISerializationContext context, Option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Answer returns SingleOptionsAnswer
	 *     OptionsAnswer returns SingleOptionsAnswer
	 *     SingleOptionsAnswer returns SingleOptionsAnswer
	 *
	 * Constraint:
	 *     (options+=SingleBoxOption+ | options+=SingleListOption+)
	 */
	protected void sequence_SingleBoxOptionsAnswer_SingleListOptionsAnswer(ISerializationContext context, SingleOptionsAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleBoxOptionsAnswer returns SingleOptionsAnswer
	 *
	 * Constraint:
	 *     options+=SingleBoxOption+
	 */
	protected void sequence_SingleBoxOptionsAnswer(ISerializationContext context, SingleOptionsAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleListOption returns Option
	 *
	 * Constraint:
	 *     (correct?='v'? option=OptionAnswer)
	 */
	protected void sequence_SingleListOption(ISerializationContext context, Option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleListOptionsAnswer returns SingleOptionsAnswer
	 *
	 * Constraint:
	 *     options+=SingleListOption+
	 */
	protected void sequence_SingleListOptionsAnswer(ISerializationContext context, SingleOptionsAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StringAnswer returns StringAnswer
	 *
	 * Constraint:
	 *     (value=STRING ignoreCase?='~'?)
	 */
	protected void sequence_StringAnswer(ISerializationContext context, StringAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Question returns StringQuestion
	 *     StringQuestion returns StringQuestion
	 *
	 * Constraint:
	 *     question=STRING
	 */
	protected void sequence_StringQuestion(ISerializationContext context, StringQuestion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExercisePackage.Literals.STRING_QUESTION__QUESTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExercisePackage.Literals.STRING_QUESTION__QUESTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringQuestionAccess().getQuestionSTRINGTerminalRuleCall_0(), semanticObject.getQuestion());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractTask returns TaskRef
	 *     TaskRef returns TaskRef
	 *
	 * Constraint:
	 *     taskRef=[Task|QName]
	 */
	protected void sequence_TaskRef(ISerializationContext context, TaskRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExercisePackage.Literals.TASK_REF__TASK_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExercisePackage.Literals.TASK_REF__TASK_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTaskRefAccess().getTaskRefTaskQNameParserRuleCall_1_0_1(), semanticObject.getTaskRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractTask returns Task
	 *     Task returns Task
	 *
	 * Constraint:
	 *     (name=ID? q=Question a=Answer)
	 */
	protected void sequence_Task(ISerializationContext context, Task semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
